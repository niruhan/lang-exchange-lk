{"ast":null,"code":"import _regeneratorRuntime from \"/Users/niruhan/MSc/source_code/new/lang-exchange-lk/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/niruhan/MSc/source_code/new/lang-exchange-lk/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/niruhan/MSc/source_code/new/lang-exchange-lk/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"/Users/niruhan/MSc/source_code/new/lang-exchange-lk/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { set, get, uniqBy } from 'lodash';\n/**\n * Component that adds Infinite scroll functionality to UI\n */\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var data = _ref.data,\n      dataKey = _ref.dataKey,\n      fetchMore = _ref.fetchMore,\n      variables = _ref.variables,\n      count = _ref.count,\n      children = _ref.children;\n  var handleScroll = useMemo(function () {\n    return (\n      /*#__PURE__*/\n      _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var loadMore, windowHeight, scrollTop, offsetHeight, scrolled;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loadMore = function loadMore() {\n                  return fetchMore({\n                    variables: _objectSpread({}, variables, {\n                      skip: data.length\n                    }),\n                    updateQuery: function updateQuery(prev, _ref3) {\n                      var fetchMoreResult = _ref3.fetchMoreResult;\n                      var previousData = get(prev, dataKey);\n                      var fetchMoreData = get(fetchMoreResult, dataKey);\n                      return set(prev, dataKey, uniqBy([].concat(_toConsumableArray(previousData), _toConsumableArray(fetchMoreData)), 'id'));\n                    }\n                  });\n                };\n\n                windowHeight = window.innerHeight;\n                scrollTop = document.documentElement.scrollTop;\n                offsetHeight = document.documentElement.offsetHeight;\n                scrolled = windowHeight + scrollTop > offsetHeight - offsetHeight / 3; // Stop event listener if all the data has been loaded\n\n                if (!(data.length >= count)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                window.removeEventListener('scroll', handleScroll);\n                return _context.abrupt(\"return\");\n\n              case 8:\n                // Load more data if user has scrolled to bottom and if there's still data in db to display\n                if (scrolled) {\n                  window.removeEventListener('scroll', handleScroll);\n                  loadMore();\n                }\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))\n    );\n  }, [count, data.length, dataKey, fetchMore, variables]);\n  useEffect(function () {\n    window.addEventListener('scroll', handleScroll);\n    return function () {\n      return window.removeEventListener('scroll', handleScroll);\n    };\n  }, [handleScroll]);\n  return children(data);\n};\n\nInfiniteScroll.propTypes = {\n  data: PropTypes.array.isRequired,\n  dataKey: PropTypes.string.isRequired,\n  count: PropTypes.number.isRequired,\n  fetchMore: PropTypes.func.isRequired,\n  variables: PropTypes.object.isRequired,\n  children: PropTypes.func.isRequired\n};\nexport default InfiniteScroll;","map":{"version":3,"sources":["/Users/niruhan/MSc/source_code/new/lang-exchange-lk/frontend/src/components/InfiniteScroll.js"],"names":["useEffect","useMemo","PropTypes","set","get","uniqBy","InfiniteScroll","data","dataKey","fetchMore","variables","count","children","handleScroll","loadMore","skip","length","updateQuery","prev","fetchMoreResult","previousData","fetchMoreData","windowHeight","window","innerHeight","scrollTop","document","documentElement","offsetHeight","scrolled","removeEventListener","addEventListener","propTypes","array","isRequired","string","number","func","object"],"mappings":"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","sourcesContent":["import { useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { set, get, uniqBy } from 'lodash';\n\n/**\n * Component that adds Infinite scroll functionality to UI\n */\nconst InfiniteScroll = ({\n  data,\n  dataKey,\n  fetchMore,\n  variables,\n  count,\n  children,\n}) => {\n  const handleScroll = useMemo(\n    () => async () => {\n      const loadMore = () => {\n        return fetchMore({\n          variables: { ...variables, skip: data.length },\n          updateQuery: (prev, { fetchMoreResult }) => {\n            const previousData = get(prev, dataKey);\n            const fetchMoreData = get(fetchMoreResult, dataKey);\n            return set(\n              prev,\n              dataKey,\n              uniqBy([...previousData, ...fetchMoreData], 'id')\n            );\n          },\n        });\n      };\n\n      const windowHeight = window.innerHeight;\n      const scrollTop = document.documentElement.scrollTop;\n      const offsetHeight = document.documentElement.offsetHeight;\n      const scrolled =\n        windowHeight + scrollTop > offsetHeight - offsetHeight / 3;\n\n      // Stop event listener if all the data has been loaded\n      if (data.length >= count) {\n        window.removeEventListener('scroll', handleScroll);\n        return;\n      }\n\n      // Load more data if user has scrolled to bottom and if there's still data in db to display\n      if (scrolled) {\n        window.removeEventListener('scroll', handleScroll);\n        loadMore();\n      }\n    },\n    [count, data.length, dataKey, fetchMore, variables]\n  );\n\n  useEffect(\n    () => {\n      window.addEventListener('scroll', handleScroll);\n\n      return () => window.removeEventListener('scroll', handleScroll);\n    },\n    [handleScroll]\n  );\n\n  return children(data);\n};\n\nInfiniteScroll.propTypes = {\n  data: PropTypes.array.isRequired,\n  dataKey: PropTypes.string.isRequired,\n  count: PropTypes.number.isRequired,\n  fetchMore: PropTypes.func.isRequired,\n  variables: PropTypes.object.isRequired,\n  children: PropTypes.func.isRequired,\n};\n\nexport default InfiniteScroll;\n"]},"metadata":{},"sourceType":"module"}